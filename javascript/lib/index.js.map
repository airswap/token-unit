{"version":3,"sources":["../src/index.js"],"names":["fs","require","unitDirectory","_","big","tokens","readdirSync","values","dirname","__dirname","TokenUnit","amount","unit","options","DP","Error","scaleAndNominalUnitData","getScaleAndNominalUnit","scaledUnit","name","scaledAmount","anchorUnit","anchor","anchorAmount","convertToAnchor","etherEquivalent","findEtherEquivalent","quoteFromTime","quoteToTime","nominalUnitFile","find","scaleData","to_anchor","starting_anchor_to_ether","scaleAmount","scaleUnitData","times","nominalAmount","nominalUnitData","anchorToEther","price","nominalUnit","toString","time","Date","now","toUnitData","scaleFromNominal","marketQuoteFrom","fromAmountToEther","marketQuoteTo","fromEtherToTokenAnchor","div","tokenUnit","to","add","subtract","sub","key","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["/**\n* TokenUnit v0.2.0\n* Convert between token units and ether units\n* (c) 2017 Airswap\n* airswap.io\n*\n* Written by Adam Link\n*/\nconst fs = require('fs')\nconst unitDirectory = '/../../units'\nconst _ = require('lodash')\nconst big = require('big.js')\n\nvar tokens = []\n\nif (typeof fs.readdirSync === \"function\") { // We are running on NodeJS\n  tokens = _.values(require('require-all')({\n    dirname: __dirname + '/' + unitDirectory\n  }))\n} else { // We may be on React\n  tokens = [\n    require(unitDirectory + '/ether.json'),\n    require(unitDirectory + '/ast.json')\n  ]\n}\n\n/**\n* TokenUnit(amount, unit)\n* @param {number} amount The number amount of tokens in the unit specified\n* @param {string} unit The unit name for the amount specified\n* @constructor\n*/\nclass TokenUnit {\n  constructor(amount, unit, options = {}) {\n    big.DP = 32 // We can handle 32 decimal places by default\n\n    if (options.big && options.big.DP) {\n      big.DP = options.big.DP\n    }\n\n    if (!big(amount) || !unit) {\n      throw new Error(\"Please provide an amount and unit during construction\")\n    }\n\n    // The nominal unit's data\n    this.scaleAndNominalUnitData = this.getScaleAndNominalUnit(unit)\n\n    // The scaled unit data\n    this.scaledUnit = this.scaleAndNominalUnitData.name\n    this.scaledAmount = big(amount)\n\n    // The common anchor unit for this nominal measurement metric\n    this.anchorUnit = this.scaleAndNominalUnitData.anchor\n    this.anchorAmount =\n      big(this.convertToAnchor(\n        this.scaledAmount,\n        this.scaleAndNominalUnitData\n      ))\n\n    // Fill in the ether equivalent for this anchor amount\n    this.etherEquivalent =\n      big(this.findEtherEquivalent(\n        this.anchorAmount,\n        this.scaleAndNominalUnitData\n      ))\n\n    // Include quote times here if applicable\n    if (options.quoteFromTime && options.quoteToTime) {\n      this.quoteFromTime = options.quoteFromTime\n      this.quoteToTime = options.quoteToTime\n    }\n  }\n\n  /**\n  * getScaleAndNominalUnit(unit)\n  * Searches the unit JSON files for the unit string specified\n  * and returns information about that nominal unit and the\n  * scaled unit\n  *\n  * @param {string} unit The unit name (nominal or scale)\n  * @return {object} The unit information found in the JSON files\n  */\n  getScaleAndNominalUnit(unit) {\n    if (!unit) {\n      throw new Error(\"Please provide a unit\")\n    }\n\n    //\n    var nominalUnitFile = _.find(tokens, { values: [ { name: unit } ] })\n    var scaleData = _.find(nominalUnitFile.values, { name: unit })\n\n    if (!nominalUnitFile || !scaleData) {\n      throw new Error(\"Unsupported unit provided\")\n    }\n\n    return {\n      name: scaleData.name,\n      to_anchor: big(scaleData.to_anchor),\n      anchor: nominalUnitFile.anchor,\n      starting_anchor_to_ether: big(nominalUnitFile.starting_anchor_to_ether),\n      unit: nominalUnitFile.unit\n    }\n  }\n\n  /**\n  * convertToAnchor(scaleAmount, nominalUnitData)\n  * Given a scaled amount and scale unit data, scale the amount to the\n  * anchor unit for the nominal unit provided\n  *\n  * @param {number} scaleAmount The quantity of unit in the scaled unit\n  * @param {object} scaleUnitData An object with the to_anchor scaling factor\n  *     to convert the scaled unit to the nominal unit\n  * @return {number} The amount of nominal units\n  */\n  convertToAnchor(scaleAmount, scaleUnitData) {\n    return big(scaleAmount).times(big(scaleUnitData.to_anchor));\n  }\n\n  /**\n  * findEtherEquivalent(nominalAmount, nominalUnitData)\n  * Given the nominal amount and nominal unit data, find what this is worth\n  * in ether.\n  *\n  * @param {number} nominalAmount The quantity of nominal units\n  * @param {object} nominalUnitData An object that can be passed to the\n  *     anchorToEther() function\n  * @return {number} The amount of ether\n  */\n  findEtherEquivalent(nominalAmount, nominalUnitData) {\n    // find the Ether Equivalent of the currency right now for quick display\n    return big(nominalAmount).times(this.anchorToEther(nominalUnitData).price) // until we add Oracle\n  }\n\n  /**\n  * anchorToEther(nominalUnit)\n  * Convert the nominal units to ether, based on either (currently only)\n  * the starting, JSON-pegged amount of nominal units to ether or\n  * (eventually) the Oracle-provided price provided by the passed in Oracle class\n  *\n  * @param {object} nominalUnit The object nominal unit information, likely from\n  *     getScaleAndNominalUnit()\n  * @return {object} An object with the conversion price and timestamp of the\n  *     quote provided\n  */\n  anchorToEther(nominalUnit) {\n    // TODO\n    // This is the function that should call the current market\n    // price via Oracle for the TokenUnit / ETH pair.\n    // It should return the value of 1 Nominal Unit in terms of ETH's ether\n    // To discuss: do we want to peg this to ether or wei?\n\n    return {\n      price: big(nominalUnit.starting_anchor_to_ether).toString(),\n      time: Date.now()\n    }\n  }\n\n  /**\n  * to(unit)\n  * The workhorse of the library that converts from one scaled unit to\n  * another scaled unit, which could be across nominal units as well. We\n  * refer to scaled to scaled, within the same nominal unit, conversions\n  * as a \"scaling conversion\" while nominal unit conversions are called\n  * \"currency conversions\" since they change the token base.\n  *\n  * @param {string} unit The new scaled unit we are converting into\n  * @return {TokenUnit} The new TokenUnit provided by the operation\n  */\n  to(unit) {\n    const toUnitData = this.getScaleAndNominalUnit(unit)\n\n    if (this.scaleAndNominalUnitData.unit == toUnitData.unit) {\n      // Just a scaling conversion\n      return new TokenUnit(\n        this.scaleFromNominal(this.anchorAmount, toUnitData.to_anchor),\n        toUnitData.name\n      )\n    } else { // Currency conversion with a new nominal unit\n      const marketQuoteFrom = this.anchorToEther(this.scaleAndNominalUnitData)\n      const fromAmountToEther =\n        big(this.anchorAmount).times(marketQuoteFrom.price)\n      const marketQuoteTo = this.anchorToEther(toUnitData)\n      const fromEtherToTokenAnchor =\n        big(fromAmountToEther).div(marketQuoteTo.price)\n\n      return new TokenUnit(\n        this.scaleFromNominal(fromEtherToTokenAnchor, toUnitData.to_anchor),\n        toUnitData.name,\n        {\n          quoteFromTime: marketQuoteFrom.time,\n          quoteToTime: marketQuoteTo.time\n        }\n      )\n    }\n  }\n\n  /**\n  * scaleFromNominal(nominalAmount, to_anchor)\n  * Given a nominal quantity and a scaling factor, scale the nominal units\n  * to the new scaled amount according to the to_anchor factor\n  *\n  * @param {number} nominalAmount The quantity of nominal units\n  * @param {number} to_anchor The conversion factor of nominal to the new\n  *     scaled unit amount\n  * @return {number} The new quantity in scaled units\n  */\n  scaleFromNominal(nominalAmount, to_anchor) {\n    return big(nominalAmount).div(big(to_anchor)).toString()\n  }\n\n  /**\n  * add(tokenUnit)\n  * Add a TokenUnit to the base TokenUnit and return a new instance of TokenUnit\n  *\n  * @param {TokenUnit} tokenUnit The TokenUnit to add to the base\n  * @return {TokenUnit} A new instance of TokenUnit with the result of the add\n  */\n  add(tokenUnit) {\n    if (!tokenUnit instanceof TokenUnit) {\n      throw new Error(\"Argument passed in must be a TokenUnit type\")\n    }\n\n    if (this.anchorUnit != tokenUnit.anchorUnit) {\n      tokenUnit = tokenUnit.to(this.anchorUnit)\n    }\n\n    return new TokenUnit(\n      this.scaleFromNominal(\n        this.anchorAmount.add(tokenUnit.anchorAmount),\n        this.scaleAndNominalUnitData.to_anchor\n      ),\n      this.scaledUnit\n    )\n  }\n\n  /**\n  * sub(tokenUnit)\n  * A facade method for subtract()\n  *\n  * @param {TokenUnit} tokenUnit The TokenUnit to subtract from the base\n  * @return {TokenUnit} A new instance of TokenUnit with the result of the\n  *     subtract\n  */\n  sub(tokenUnit) {\n    return this.subtract(tokenUnit)\n  }\n\n  /**\n  * subtract(tokenUnit)\n  * Subtract a TokenUnit from the base TokenUnit and return a new instance of\n  * TokenUnit\n  *\n  * @param {TokenUnit} tokenUnit The TokenUnit to subtract from the base\n  * @return {TokenUnit} A new instance of TokenUnit with the result of the\n  *     subtract\n  */\n  subtract(tokenUnit) {\n    if (!tokenUnit instanceof TokenUnit) {\n      throw new Error(\"Argument passed in must be a TokenUnit type\")\n    }\n\n    if (this.anchorUnit != tokenUnit.anchorUnit) {\n      tokenUnit = tokenUnit.to(this.anchorUnit)\n    }\n\n    return new TokenUnit(\n      this.scaleFromNominal(\n        this.anchorAmount.sub(tokenUnit.anchorAmount),\n        this.scaleAndNominalUnitData.to_anchor\n      ),\n      this.scaledUnit\n    )\n  }\n\n  /**\n  * toString()\n  * Useful for console logging just the important parts\n  *\n  * @return {object} It actually returns an object though\n  */\n  toString() {\n    return {\n      scaledUnit: this.scaleAndNominalUnitData.name,\n      scaledAmount: this.scaledAmount.toString(),\n      anchorUnit: this.scaleAndNominalUnitData.anchor,\n      anchorAmount: this.anchorAmount.toString(),\n      etherEquivalent: this.etherEquivalent.toString()\n    }\n  }\n\n  /**\n  * get(key)\n  * A simple getter function to make accessing parts of the TokenUnit easier\n  *\n  * @param {string} key The key to get from the TokenUnit\n  * @return {string|number} The value of the key\n  */\n  get(key) {\n    return this.toString()[key]\n  }\n}\n\nmodule.exports = TokenUnit\n"]}